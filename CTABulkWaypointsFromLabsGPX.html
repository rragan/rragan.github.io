<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Generate CTA bulk waypoints for labs from GPX</title>
<link media="screen" href="style.css" type="text/css" rel="stylesheet">
</head>

<body>
<h2>Generate CTA bulk waypoints for labs from GPX</h2>
<h3>Choose a GPX file or zipped GPX file. Handles Cachly, GeeohGo and labs2gpx files.</h3>
<input type="file" id="file" name="file" />
<br/>
<textarea id="list" rows="25" cols="80"></textarea>
<br><b>Reload page to run again</b>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.9.1/jszip.min.js"></script>
<script type="text/javascript">
var textArea = document.createElement('area');
var output = [];
var skippingToLab = false;
var geeohGo = false;

$("#file").on("change", function(evt) {
    var files = evt.target.files;
    if (files[0].name.endsWith(".zip")) {
    	handleZipFile(files[0]);
    } else {
    	var reader = new FileReader();
    	reader.onload = function(evt) {
    		processXML(this.result);
    	};
    	reader.readAsText(files[0]);
    }

    // Closure to capture the file information.
    function handleZipFile(f) {
        getZipFilesContent(f).then(dd => {
            processXML(dd);
        }).catch(e => {
            console.log(e);
        });
    }
});

async function getZipFilesContent(data) {
    const zipContent = [];
    const promises = [];
    const zip = (await JSZip.loadAsync(data));
    zip.forEach(async (relativePath, file) => {
        const promise = file.async('string');
        promises.push(promise);
        zipContent.push({
            file: relativePath,
            content: await promise
        });
    });
    await Promise.all(promises);
    return zipContent[0].content;
}

function processXML(dd) {
    var lines = dd.split('\n');
    var line = '';
    var m4 = null;
    var m5 = null;
    var name = null;
    var url = "";
    var descFull = "";
    descDone = false;
    var descMode = false;
	for (var i = 0; i < lines.length; i++) {
	    var re2 = /<wpt lat=\"(-?[0-9\.]+)\"\s+lon=\"(-?[0-9\.]+)\"/g;
	    var re3 = /<groundspeak:name>(.*)<\/groundspeak:name>/g;
	    var re5 = /<url>(.*)<\/url>/g;
		line = lines[i];
		if (line.indexOf("creator=\"Geooh") >= 0) {
			processGeeohGoXML(lines);
		}
		var parts = line.split(/<\/wpt>/);
		if (parts.length > 1) {
			line = parts[0]; // get first part up to /wpt
			var rest = parts.slice(1);
			rest = rest.join('');
			lines[i+1] = rest + lines[i+1];
		}
		if (line.indexOf("<type>Geocache|") >= 0 && line.indexOf("Lab") < 0) {
			skippingToLab = true;
			coords= null;
		}
		if (skippingToLab) {
			continue;
		}
        var m2 = re2.exec(line);
        var m3 = re3.exec(line);
        var m5 = re5.exec(line);

        if(line.indexOf("<groundspeak:long_description") >= 0) {
        	line=line.replace(/\s*<groundspeak:long_description html="False">\s*/g, "");
        	line = line.trim();
        	descMode = true;
        }

        if(descMode) {
         	if(line.indexOf("\</groundspeak:long_description") >= 0 ) {
				line=line.replace(/\s*<\/groundspeak:long_description>\s*/g,"");
				descFull += line;
				descMode = false;
				m4 = descFull;
				descFull = "";
			} else {
				descFull += line.trim();
			}
		}

        if (m2 !== null) {
            var lat = m2[1];
            var lon = m2[2];
            var coords = lat + "," + lon;
        }
        if (m3 !== null) {
            name = m3[1];
        }
        if (m5 !== null) {
            url = m5[1];
        }

		if ((name !== null) && (coords!== null) && (m4!== null) && (url !== null)) {
			m4 = stripHtml(m4);
			m4 = decodeHTMLEntities(m4);
			// Strip out excess from labs2gpx HTML. Cachetur limit is 1024 chars.
			m4 = m4.replace(/.*Waypoint Description/,"");
			m4 = m4.replace(/https:\/\/.*Question/,"Question");
			m4= m4.replace(/Adventure Lab Descriptions.*/,"");
			m4 = m4.replace(/Award Information.*/,"");
			var linkDesc = url + " " + m4;
			if (linkDesc.length > 1024) {
				linkDesc = linkDesc.substr(0, 1021) + "...";
			}
			line = decodeHTMLEntities(name) + ';lab;' + coords + ';' + linkDesc  + '\n';
			output.push(line);
			coords = null;
			name = null;
			m4 = null;
			m5 = null;
        }

    }
    updateView(output);
}

function processGeeohGoXML(dd) {
    var m1;
    var m2;
    var m3;
    var m4 = null;
    var m5 = null;
    var alName = "";
    var alUrl = "";
    var line;
	var lines = dd.join('');
	lines = lines.replace(/\r/gm,"");
	lines = lines.split(/<wpt /);

	for (var i = 1; i < lines.length; i++) {
		var re1 = /<urlname>(.*)<\/urlname>/g;
	    var re2 = /lat=\"(-?[0-9\.]+)\"\s+lon=\"(-?[0-9\.]+)\"/g;
	    var re3 = /<name>(.*)<\/name>/g;
   		var re4 = /<desc>(.*)<\/desc>/g;
   		var re5 = /<url>(.*)<\/url>/g;

		line = lines[i];
		m1 = re1.exec(line);
		// Get Overarching AL name
		if(m1 && line.indexOf("<type>Geocache|Adventure Lab" >= 0)) {
			alName = m1[1];
		}
		m5 = re5.exec(line);
		if(m5 && line.indexOf("<type>Geocache|Adventure Lab" >= 0)) {
			alUrl = m5[1];
		}
		if (line.indexOf("<groundspeak:owner id") >= 0 ||(line.indexOf("<type>Waypoint|") >= 0 && line.indexOf("<type>Waypoint|Stage") < 0 )) {
			continue;
		}

		coords= null;

        m2 = re2.exec(line);
        m3 = re3.exec(line);
        m4 = re4.exec(line);

        if (m2 !== null) {
            var lat = m2[1];
            var lon = m2[2];
            var coords = lat + "," + lon;
        }
        if (m3 !== null) {
            name = m3[1];
        }

		if (m4 !== null) {
		    m4 = m4[1];
			m4 = stripHtml(m4);
			m4 = decodeHTMLEntities(m4);
			var linkDesc = alUrl + " " + m4;
			if (linkDesc.length > 1024) {
				linkDesc = linkDesc.substr(0, 1021) + "...";
			}
			line = alName + ": " + decodeHTMLEntities(name) + ';lab;' + coords + ';' + linkDesc  + '\n';

			output.push(line);
			coords = null;
			name = null;
			m4 = null;
			m5 = null;
        }
    }
    updateView(output);
}

function updateView(output) {
    var outarea = document.getElementById('list');
    // Remove last newline
    if (output) {
		output[output.length -1] = output[output.length -1].trim();
		outarea.value = output.join(' '),
		outarea.setSelectionRange(0, 99999);
	}
}

function decodeHTMLEntities(text) {
  text=text.replace(/;/g, "");
  text=text.replace(/"/g,"'");
  textArea.innerHTML = text;
  return textArea.innerText;
}

function stripHtml(text) {
  textArea.innerHTML = text;
  return textArea.textContent;
}

</script>
</body>
</html>
